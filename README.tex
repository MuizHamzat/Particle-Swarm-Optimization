\documentclass[12pt]{article}
\usepackage{ragged2e} % load the package for justification
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{pgfplots}
\usepackage{tikz}
\usetikzlibrary{fadings}
\usepackage{filecontents}
\usepackage{multirow}
\usepackage{amsmath}
\pgfplotsset{width=10cm,compat=1.17}
\setlength{\parskip}{0.75em} % Set the space between paragraphs
\usepackage{setspace}
\setstretch{1.2} % Adjust the value as per your preference
\usepackage[margin=2cm]{geometry} % Adjust the margin
\setlength{\parindent}{0pt} % Adjust the value for starting paragraph
\usetikzlibrary{arrows.meta}
\usepackage{mdframed}
\usepackage{float}

\usepackage{hyperref}

% to remove the hyperline rectangle
\hypersetup{
	colorlinks=true,
	linkcolor=black,
	urlcolor=blue
}

\usepackage{xcolor}
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{listings}
\usepackage{tcolorbox}
\usepackage{lipsum} % Example text package
\usepackage{fancyhdr} % Package for customizing headers and footers

\usepackage{algorithm}
\usepackage{algpseudocode}

% Define the orange color
\definecolor{myorange}{RGB}{255,65,0}
% Define a new color for "cherry" (dark red)
\definecolor{cherry}{RGB}{148,0,25}
\definecolor{codegreen}{rgb}{0,0.6,0}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Apply the custom footer to all pages
\pagestyle{fancy}

% Redefine the header format
\fancyhead{}
\fancyhead[R]{\textcolor{orange!80!black}{\itshape\leftmark}}

\fancyhead[L]{\textcolor{black}{\thepage}}


% Redefine the footer format with a line before each footnote
\fancyfoot{}
\fancyfoot[C]{\footnotesize \textbf{Muiz Hamzat}, McMaster University, MECHTRON 2MP3 - Programming for Mechatronics. \footnoterule}

% Redefine the footnote rule
\renewcommand{\footnoterule}{\vspace*{-3pt}\noindent\rule{0.0\columnwidth}{0.4pt}\vspace*{2.6pt}}

% Set the header rule color to orange
\renewcommand{\headrule}{\color{orange!80!black}\hrule width\headwidth height\headrulewidth \vskip-\headrulewidth}

% Set the footer rule color to orange (optional)
\renewcommand{\footrule}{\color{black}\hrule width\headwidth height\headrulewidth \vskip-\headrulewidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Set the color for the section headings
\titleformat{\section}
{\normalfont\Large\bfseries\color{orange!80!black}}{\thesection}{1em}{}

% Set the color for the subsection headings
\titleformat{\subsection}
{\normalfont\large\bfseries\color{orange!80!black}}{\thesubsection}{1em}{}

% Set the color for the subsubsection headings
\titleformat{\subsubsection}
{\normalfont\normalsize\bfseries\color{orange!80!black}}{\thesubsubsection}{1em}{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Set the color for the table of contents
\titlecontents{section}
[1.5em]{\color{orange!80!black}}
{\contentslabel{1.5em}}
{}{\titlerule*[0.5pc]{.}\contentspage}

% Set the color for the subsections in the table of contents
\titlecontents{subsection}
[3.8em]{\color{orange!80!black}}
{\contentslabel{2.3em}}
{}{\titlerule*[0.5pc]{.}\contentspage}

% Set the color for the subsubsections in the table of contents
\titlecontents{subsubsection}
[6em]{\color{orange!80!black}}
{\contentslabel{3em}}
{}{\titlerule*[0.5pc]{.}\contentspage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% set a format for the codes inside a box with C format
\lstset{
	language=C,
	basicstyle=\ttfamily,
	backgroundcolor=\color{blue!5},
	keywordstyle=\color{blue},
	commentstyle=\color{codegreen},
	stringstyle=\color{red},
	showstringspaces=false,
	breaklines=true,
	frame=single,
	rulecolor=\color{lightgray!35}, % Set the color of the frame
	numbers=none,
	numberstyle=\tiny,
	numbersep=5pt,
	tabsize=1,
	morekeywords={include},
	alsoletter={\#},
	otherkeywords={\#}
}




%\input listings.tex



% Define a command for inline code snippets with a colored and rounded box
\newtcbox{\codebox}[1][gray]{on line, boxrule=0.2pt, colback=blue!5, colframe=#1, fontupper=\color{cherry}\ttfamily, arc=2pt, boxsep=0pt, left=2pt, right=2pt, top=3pt, bottom=2pt}




\tikzset{%
	every neuron/.style={
		circle,
		draw,
		minimum size=1cm
	},
	neuron missing/.style={
		draw=none, 
		scale=4,
		text height=0.333cm,
		execute at begin node=\color{black}$\vdots$
	},
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define a new tcolorbox style with default options
\tcbset{
	myboxstyle/.style={
		colback=orange!10,
		colframe=orange!80!black,
	}
}

% Define a new tcolorbox style with default options to print the output with terminal style


\tcbset{
	myboxstyleTerminal/.style={
		colback=blue!5,
		frame empty, % Set frame to empty to remove the fram
	}
}

\mdfdefinestyle{myboxstyleTerminal1}{
	backgroundcolor=blue!5,
	hidealllines=true, % Remove all lines (frame)
	leftline=false,     % Add a left line
}


\begin{document}
	
	\justifying
	
	\begin{center}
		\textbf{{\large Assignment 4}}
		
		\textbf{Developing Particle Swarm Optimization (PSO) in C with Case Study} 
		
		\textbf{Muiz Hamzat - 400500321}
		
	\end{center}
	

	
	
	
	\section{Introduction}
	
	For this assignment, we were tasked with using Partice Swarm Optimization (PSO) to optimize a set of functions. The PSO algorithm is a population-based optimization algorithm that is inspired by the social behavior of birds flocking or fish schooling. The behavior of the particles in the swarm is influenced by their own best position and the best position of the entire swarm. The particles work together to find the optimal fitness of the objective function. In this assignment, we will implement the PSO algorithm in C and analyze the performance of the algorithm by varying the number of variables (dimensions) and particles.

	The objective functions analyzed in this assignment can be found \href{https://www.sfu.ca/~ssurjano/optimization.html}{here}.
	
	

	
	
	\section{Particle Swarm Optimization (PSO) Formulation}
	
	
	Each particle has a position and velocity in the search space. The position of the particle is represented by a vector \(x_i(t)\) and the velocity of the particle is represented by a vector \(v_i(t)\). Initially, the positions and velocities of each particle are random values, and they are updated using the following equations:
	
	\[
	x_{ij}(t+1) = x_{ij}(t) + v_{ij}(t+1)
	\]

	\[
	v_{ij}(t+1) = w \cdot v_{ij}(t) + c_1 \cdot r_1 \cdot (p_{ij} - x_{ij}(t)) + c_2 \cdot r_2 \cdot (g_j - x_{ij}(t))
	\]

	
	Each particle also has a personal best position, which is the position that gives the best fitness value for that particle. The personal best position is represented by a vector \(p_i\). The global best position is the position that gives the best fitness value for the entire swarm. The global best position is represented by a vector \(g\). The personal best and global best positions are updated as follows:
	
	\begin{enumerate}
		\item Evaluate the fitness of each particle at its new position: \(f(\mathbf{x}_i(t+1))\).
		
		\item Update personal best:
		
		\[
		\mathbf{p}_i = 
		\begin{cases} 
			\mathbf{x}_i(t+1) & \text{if } f(\mathbf{x}_i(t+1)) < f(\mathbf{p}_i) \\
			\mathbf{p}_i & \text{otherwise.}
		\end{cases}
		\]
		
		Update global best:
		
		\[
		\mathbf{g} = \arg\min_{\mathbf{p}_i} f(\mathbf{p}_i).
		\]
	\end{enumerate}
	
	
	The algorithm continually updates these values until a stopping criterion is met. For this assignment, the program will stop when the global best fitness value does not change for 500 iterations, or if the entered number of iterations has been reached. It will then print out the global best fitness value and the global best position, as well as the CPU time taken to calculate the optimal fitness value.
	


    For example, if the executeable file was ran with the following arguments:
    
    \codebox{./pso griewank 10 -600 600 20000 1000} 
    
    then the following woud be printed to the terminal:
	
	\begin{mdframed}[style=myboxstyleTerminal1]
		\footnotesize
		\begin{verbatim}
			
			Objective Function: griewank
			The number of variables: 10
			Lower Bound for all variables: -600.000000
			Upper Bound for all variables:  600.000000
			------------------------------------------------
			PSO with is initiated:
			Number of particles  = 20000
			Number of iterations = 10000

			Iteration #0: OF = 48.834937
			Variables: { 137.037874 -77.413037 
    -109.854260 69.559942 226.114482 79.516750 
    -140.576342 -260

			Stopped at iteration #965

			
			Results
			------------------------------------------------
			CPU time: 9.27 seconds
			Optimal fitness: 0.000000
			Optimal position: 0.000000 -0.000000 -0.000000
    0.000000 0.000000 -0.000000 0.000000 0.000000
    -0.000000 0.000000
		\end{verbatim}
	\end{mdframed}
	
	Finally, these are the tables of test cases. The tables show the optimal fitness value and the CPU time taken to calculate the optimal fitness value for each function, and are separated by the number of variables (dimensions) used in the functions.
	
	\begin{table}[H]
		\caption{\codebox{NUM\_VARIABLES = 10} (or dimension $d=10$) in \textbf{all} functions}
		\label{table:1}
		\centering
		\begin{tabular}{l c c c c c c c}
			\hline
			Function &  \multicolumn{2}{c}{Bound} & Particles & Iterations &  Optimal Fitness & CPU time (Sec) \\
			& Lower& Upper&&&\\
			\hline
			Griewank  		&  -600   & 600 	&20000 &965  &0  &9.49 &\\
			Levy 	  		&  -10    & 10 		&20000 &644 &0 &6.69 &\\
			Rastrigin 		&  -5.12  & 5.12 	&20000 &714 &0 &6.23 &\\
			Rosenbrock		&  -5     & 10 		&25000 &5414 &0 &40.04 &\\
			Schwefel 	 	&  -500   & 500 	&30500 &734 &1.27E-3 &10.57 &\\
			Dixon-Price 	&   -10	  & 10 		&20000 &668 &0.667 &4.65 &\\
			Michalewicz 	&   0 	  & $\pi$ 	&30000 &1116 &-9.660 &33.53 &\\
			Styblinski-Tang & -5 	  & 5  		&500 &737 &-391.662 &0.42 &\\
			\hline
		\end{tabular}
	\end{table}
	
	
	\begin{table}[H]
		\caption{\codebox{NUM\_VARIABLES = 50} (or dimension $d=50$) in \textbf{all} functions}
		\label{table:1}
		\centering
		\begin{tabular}{l c c c c c c c}
			\hline
			Function &  \multicolumn{2}{c}{Bound} & Particles & Iterations &  Optimal Fitness & CPU time (Sec) \\
			& Lower& Upper&&&\\
			\hline
			Griewank  		&  -600   & 600 	&5000 &739 &0 &8.48 &\\
			Levy 	  		&  -10    & 10 		&5000 &971 &0 &12.08 &\\
			Rastrigin 		&  -5.12  & 5.12 	&100000 &50738 &0 &7232.78 &\\
			Rosenbrock		&  -5     & 10 		&100000 &51581 &0 &9751.36 &\\
			Schwefel 	 	&  -500   & 500 	&100000 &51190 &1.27E-3 &7741.98 &\\
			Dixon-Price 	&   -10	  & 10 		&50000 &875 &0.667 &75.39 &\\
			Michalewicz 	&   0 	  & $\pi$ 	&40000 &10849 &-47.760 &5872.18 &\\
			Styblinski-Tang & -5 	  & 5  		&23000 &6171 &1958.30 &5529.93 &\\
			\hline
		\end{tabular}
	\end{table}
	
	\begin{table}[H]
		\caption{\codebox{NUM\_VARIABLES = 100} (or dimension $d=100$) in \textbf{all} functions}
		\label{table:1}
		\centering
		\begin{tabular}{l c c c c c c c}
			\hline
			Function &  \multicolumn{2}{c}{Bound} & Particles & Iterations &  Optimal Fitness & CPU time (Sec) \\
			& Lower& Upper&&&\\
			\hline
			Griewank  		&  -600   & 600 		&10000 &1110 &0 &51.42 &\\
			Levy 	  		&  -10    & 10 		&30000 &5168 &0 &2941.48 &\\
			Rastrigin 		&  -5.12  & 5.12 	&100000 &54092 &0 &16513.03 &\\
			Rosenbrock		&  -5     & 10 		&100000 &70294 &0 &20012.42 &\\
			Schwefel 	 	&  -500   & 500 	&100000 &65029 &1.27E-3 &18314.78 &\\
			Dixon-Price 	&   -10	  & 10 		&30000 &14961 &0.667 &1839.85 &\\
			Michalewicz 	&   0 	  & $\pi$ 	&40000 &5848 &-96.167 &1252.60 &\\
			Styblinski-Tang & -5 	  & 5  		&50000 &2747 &-3916.60 &960.39 &\\
			\hline
		\end{tabular}
	\end{table}
	
	
	
	
	
	
	 
	\newpage
	\section{Appendix}
	
	\begin{lstlisting}[basicstyle=\small]
		// ##### utility.h #####
#ifndef UTILITY_H
#define UTILITY_H

// Function pointer type for objective functions
typedef double (*ObjectiveFunction)(int, double *);

typedef struct Bound{
    double lowerBound;
    double upperBound;
}Bound;


// Function prototypes
double random_double(double min, double max);
double pso(ObjectiveFunction objective_function, int NUM_VARIABLES, Bound *bounds, int NUM_PARTICLES, int MAX_ITERATIONS, double best_position[]);

#endif // UTILITY_H

// ##### PSO.c #####
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>
#include "OF_lib.h"
#include "utility.h"

// Helper function to generate random numbers in a range
double random_double(double min, double max) {
    return min + (max - min) * ((double)rand() / RAND_MAX);
}

double pso(ObjectiveFunction objective_function, int NUM_VARIABLES, Bound *bounds, int NUM_PARTICLES, int MAX_ITERATIONS, double *best_position) {
    //PSO Parameters
    double w = 0.7;
    double c1 = 1.5;
    double c2 = 1.5;

    //Allocate memory for number of particles
    double** x = malloc(sizeof(double*) * (long unsigned int)NUM_PARTICLES);
    double** v = malloc(sizeof(double*) * (long unsigned int)NUM_PARTICLES);    
    double** p = malloc(sizeof(double*) * (long unsigned int)NUM_PARTICLES);
    double* fpBest = malloc(sizeof(double) * (long unsigned int)NUM_PARTICLES);
    double* g = malloc(sizeof(double) * (long unsigned int)NUM_VARIABLES);

    //Check if memory allocation failed
    if (!x || !v || !p || !fpBest || !g){
                printf("Memory allocation failed. Exiting program.");
                exit(1);
            }
    
    //Allocate memory for number of variables for each particle
    int i,j;
    for (i=0; i < NUM_PARTICLES; i++){
        x[i] = malloc(sizeof(double) * (long unsigned int)NUM_VARIABLES);        
        v[i] = malloc(sizeof(double) * (long unsigned int)NUM_VARIABLES);
        p[i] = malloc(sizeof(double) * (long unsigned int)NUM_VARIABLES);

        //Check if memory allocation failed
        if (!x[i] || !v[i] || !p[i]){
            printf("Memory allocation failed. Exiting program.");
            exit(1);
        }
    }

    //Set best global fitness value to a very large number initially. That way, whatever the first personal fitness value found is, it will become the global fitness value
    double fgBest = DBL_MAX;

    //INITIALIZATION
    //Give particles random initial positions, velocities, and personal fitness values
    for(i=0; i < NUM_PARTICLES; i++){
        for (j=0; j < NUM_VARIABLES; j++){
            x[i][j] = random_double(bounds[j].lowerBound, bounds[j].upperBound);
            v[i][j] = random_double(-1.0, 1.0);
            p[i][j] = x[i][j];
        }
        //Find the personal best fitness value of each particle. If it's better than the global best fitness value, replace it, and the best global position
        fpBest[i] = objective_function(NUM_VARIABLES, x[i]);
        if (fpBest[i] < fgBest){
            fgBest = fpBest[i];
            for (j=0; j < NUM_VARIABLES; j++){
                g[j] = p[i][j];
            }
        }
    }

    //PSO Loop
    int iter; //Iteration counter
    int stopper = 0; //Counter to stop the loop if the global best fitness value doesn't change for a certain number of iterations (stagnates)
    double prev_fgBest;
    int stagnationCounter[NUM_PARTICLES]; //Counter to keep track of how many iterations a particle's personal best fitness value hasn't changed
    for (iter=0; iter < MAX_ITERATIONS; iter++){
        prev_fgBest = fgBest;

        //Print out the global best fitness value and position every 1000 iterations
        if (iter % 1000 == 0){
            printf("Iteration #%i: OF = %lf\nVariables: { ", iter, fgBest);
            for (int j = 0; j < NUM_VARIABLES; j++) {
                printf("%lf ", g[j]);
            }
            printf("}\n\n");
        }

        //Update each particle's position and velocity
        for (i=0; i < NUM_PARTICLES; i++){
            for (j=0; j < NUM_VARIABLES; j++){
                double r1 = random_double(0,1);
                double r2 = random_double(0,1);
                //Update velocity
                v[i][j] = w *v[i][j]+c1*r1*(p[i][j]-x[i][j])+c2*r2*(g[j]-x[i][j]);
                //Update position
                x[i][j] += v[i][j];
                //Clamp x[i][j] within bounds
                if (x[i][j] < bounds[j].lowerBound) {x[i][j] = bounds[j].lowerBound;}
                if (x[i][j] > bounds[j].upperBound) {x[i][j] = bounds[j].upperBound;}
            }

            //Calculate fitness value and compare it with particle's best fitness value. If the current fitness value is better, replace it and the particle's personal best position
            double f = objective_function(NUM_VARIABLES, x[i]);
            if (f < fpBest[i]){
                fpBest[i] = f;
                for (j=0; j < NUM_VARIABLES; j++){
                    p[i][j] = x[i][j];
                }
                stagnationCounter[i] = 0;
            } else{
                stagnationCounter[i]++;
            }

            //The same thing but for the global best fitness value and position
            if (f < fgBest){
                fgBest = f;
                for (j=0; j < NUM_VARIABLES; j++){
                    g[j] = x[i][j];
                }
            }
        }

        // Adaptive parameter adjustment based on performance
        for (i = 0; i < NUM_PARTICLES; i++) {
            if (stagnationCounter[i] > 100) {
                // Increase cognitive component to encourage exploration
                c1 = 2.0;
                c2 = 1.0;
            } else {
                // Reset to default values
                c1 = 1.5;
                c2 = 1.5;
            }
        }

        //Stopping condition: If the global best fitness value doesn't change for 500 iterations, stop the loop
        if (fabs(prev_fgBest-fgBest) < 1e-15) {
            stopper++;
        } else {
            stopper = 0;
        }

        if (stopper == 500) {
            printf("Stopped at iteration #%i\n", iter + 1);
            break;
        }
    }

    //AFTER PSO LOOP
    //Save the global best position to the best_position paramter 
    for (j=0; j < NUM_VARIABLES; j++){
        best_position[j] = g[j];
    }

    //Deallocating
    for (i=0; i < NUM_PARTICLES; i++){
        free(x[i]);
        free(v[i]);
        free(p[i]);
    }

    free(x);
    free(v);
    free(p);
    free(fpBest);
    free(g);

    return fgBest;
}
	\end{lstlisting}
	
\end{document}